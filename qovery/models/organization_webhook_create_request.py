# coding: utf-8

"""
    Qovery API

    - Qovery is the fastest way to deploy your full-stack apps on any Cloud provider. - ℹ️ The API is stable and still in development. 

    The version of the OpenAPI document: 1.0.3
    Contact: support+api+documentation@qovery.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json


from typing import Any, ClassVar, Dict, List, Optional
from pydantic import BaseModel, StrictBool, StrictStr
from pydantic import Field
from qovery.models.environment_mode_enum import EnvironmentModeEnum
from qovery.models.organization_webhook_event_enum import OrganizationWebhookEventEnum
from qovery.models.organization_webhook_kind_enum import OrganizationWebhookKindEnum
try:
    from typing import Self
except ImportError:
    from typing_extensions import Self

class OrganizationWebhookCreateRequest(BaseModel):
    """
    OrganizationWebhookCreateRequest
    """ # noqa: E501
    kind: OrganizationWebhookKindEnum
    target_url: StrictStr = Field(description="Set the public HTTP or HTTPS endpoint that will receive the specified events. The target URL must starts with `http://` or `https://` ")
    target_secret: Optional[StrictStr] = Field(default=None, description="Make sure you receive a payload to sign the Qovery request with your secret. Qovery will add a HTTP header `Qovery-Signature: <Your Secret>` to every webhook requests sent to your target URL. ")
    description: Optional[StrictStr] = None
    enabled: Optional[StrictBool] = Field(default=None, description="Turn on or off your endpoint.")
    events: List[OrganizationWebhookEventEnum]
    project_names_filter: Optional[List[StrictStr]] = Field(default=None, description="Specify the project names you want to filter to.  This webhook will be triggered only if the event is coming from the specified Project IDs. Notes: 1. Wildcard is accepted E.g. `product*`. 2. Name is case insensitive. ")
    environment_types_filter: Optional[List[EnvironmentModeEnum]] = Field(default=None, description="Specify the environment modes you want to filter to. This webhook will be triggered only if the event is coming from an environment with the specified mode. ")
    __properties: ClassVar[List[str]] = ["kind", "target_url", "target_secret", "description", "enabled", "events", "project_names_filter", "environment_types_filter"]

    model_config = {
        "populate_by_name": True,
        "validate_assignment": True,
        "protected_namespaces": (),
    }


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Create an instance of OrganizationWebhookCreateRequest from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        _dict = self.model_dump(
            by_alias=True,
            exclude={
            },
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Dict) -> Self:
        """Create an instance of OrganizationWebhookCreateRequest from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "kind": obj.get("kind"),
            "target_url": obj.get("target_url"),
            "target_secret": obj.get("target_secret"),
            "description": obj.get("description"),
            "enabled": obj.get("enabled"),
            "events": obj.get("events"),
            "project_names_filter": obj.get("project_names_filter"),
            "environment_types_filter": obj.get("environment_types_filter")
        })
        return _obj


